import { Pool, Client } from 'pg';
import { User, UserResponse } from '../models/User';
import { Membership, MembershipResponse, DEFAULT_MEMBERSHIP_TIERS } from '../models/Membership';

let pool: Pool | null = null;

export const initPostgres = async (): Promise<Pool | null> => {
  const connectionString = process.env.POSTGRES_URL;
  
  if (!connectionString) {
    console.warn('PostgreSQL connection string not found. PostgreSQL mode disabled.');
    return null;
  }

  try {
    pool = new Pool({
      connectionString,
      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });

    // Test connection
    const client = await pool.connect();
    await client.query('SELECT NOW()');
    client.release();
    
    console.log('✅ PostgreSQL connected successfully');
    
    // Initialize tables
    await initializeTables();
    
    return pool;
  } catch (error) {
    console.error('❌ PostgreSQL connection failed:', error);
    pool = null;
    return null;
  }
};

export const getPostgresPool = (): Pool | null => {
  return pool;
};

export const isPostgresEnabled = (): boolean => {
  return pool !== null;
};

const initializeTables = async (): Promise<void> => {
  if (!pool) return;
  
  try {
    const client = await pool.connect();
    
    // Create memberships table first (referenced by users)
    await client.query(`
      CREATE TABLE IF NOT EXISTS memberships (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL UNIQUE,
        price DECIMAL(10,2) NOT NULL DEFAULT 0,
        features JSONB NOT NULL DEFAULT '[]'::jsonb,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
    `);
    
    // Create users table (email-first design)
    await client.query(`
      CREATE TABLE IF NOT EXISTS users (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        email VARCHAR(255) UNIQUE NOT NULL,          -- Primary identifier
        username VARCHAR(100) UNIQUE NOT NULL,       -- Required unique username
        name JSONB,                                   -- Optional structured name {first_name, last_name}
        wallet_address VARCHAR(42) NOT NULL DEFAULT '', -- Generated by WalletConnect
        ens_name VARCHAR(255),                       -- Optional ENS on Base
        membership_tier_id UUID REFERENCES memberships(id) ON DELETE SET NULL DEFAULT '1',
        membership_assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        is_wallet_verified BOOLEAN DEFAULT FALSE,
        wallet_type VARCHAR(100) NOT NULL DEFAULT 'WalletConnect',
        last_wallet_connection TIMESTAMP WITH TIME ZONE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
    `);
    
    // Create indexes
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
      CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
      CREATE INDEX IF NOT EXISTS idx_users_wallet_address ON users(wallet_address) WHERE wallet_address != '';
      CREATE INDEX IF NOT EXISTS idx_users_membership_tier_id ON users(membership_tier_id);
      CREATE INDEX IF NOT EXISTS idx_users_wallet_type ON users(wallet_type);
      CREATE INDEX IF NOT EXISTS idx_users_is_verified ON users(is_wallet_verified);
      CREATE INDEX IF NOT EXISTS idx_users_created_at ON users(created_at);
      CREATE INDEX IF NOT EXISTS idx_memberships_name ON memberships(name);
      CREATE INDEX IF NOT EXISTS idx_memberships_price ON memberships(price);
    `);
    
    // Create updated_at trigger
    await client.query(`
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';
    `);
    
    await client.query(`
      DROP TRIGGER IF EXISTS update_users_updated_at ON users;
      CREATE TRIGGER update_users_updated_at
        BEFORE UPDATE ON users
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column();
        
      DROP TRIGGER IF EXISTS update_memberships_updated_at ON memberships;
      CREATE TRIGGER update_memberships_updated_at
        BEFORE UPDATE ON memberships
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column();
    `);
    
    // Seed default membership tiers
    await seedMembershipTiers(client);
    
    client.release();
    console.log('✅ PostgreSQL tables initialized');
  } catch (error) {
    console.error('❌ Error initializing PostgreSQL tables:', error);
  }
};

export const closePostgresConnection = async (): Promise<void> => {
  if (pool) {
    await pool.end();
    pool = null;
    console.log('PostgreSQL connection closed');
  }
};

// Database helper functions
export const postgresQuery = async (text: string, params?: any[]): Promise<any> => {
  if (!pool) throw new Error('PostgreSQL not initialized');
  
  const client = await pool.connect();
  try {
    const result = await client.query(text, params);
    return result;
  } finally {
    client.release();
  }
};

export const formatPostgresUser = (pgUser: any): UserResponse => ({
  id: pgUser.id,
  email: pgUser.email,
  username: pgUser.username,
  name: pgUser.name ? (typeof pgUser.name === 'string' ? JSON.parse(pgUser.name) : pgUser.name) : undefined,
  walletAddress: pgUser.wallet_address,
  ensName: pgUser.ens_name,
  membershipTier: pgUser.membership_tier_id ? {
    id: pgUser.membership_tier_id,
    name: pgUser.membership_name || '',
    price: parseFloat(pgUser.membership_price || '0'),
    features: pgUser.membership_features || []
  } : undefined,
  membershipAssignedAt: pgUser.membership_assigned_at,
  isWalletVerified: pgUser.is_wallet_verified || false,
  walletType: pgUser.wallet_type,
  lastWalletConnection: pgUser.last_wallet_connection,
  createdAt: pgUser.created_at,
  updatedAt: pgUser.updated_at
});

export const formatPostgresUserToModel = (pgUser: any): User => ({
  id: pgUser.id,
  email: pgUser.email,
  username: pgUser.username,
  name: pgUser.name ? (typeof pgUser.name === 'string' ? JSON.parse(pgUser.name) : pgUser.name) : undefined,
  walletAddress: pgUser.wallet_address,
  ensName: pgUser.ens_name,
  membershipTierId: pgUser.membership_tier_id,
  membershipAssignedAt: new Date(pgUser.membership_assigned_at),
  isWalletVerified: pgUser.is_wallet_verified || false,
  walletType: pgUser.wallet_type,
  lastWalletConnection: pgUser.last_wallet_connection ? new Date(pgUser.last_wallet_connection) : undefined,
  createdAt: new Date(pgUser.created_at),
  updatedAt: new Date(pgUser.updated_at)
});

// Membership formatting functions
export const formatPostgresMembership = (pgMembership: any): MembershipResponse => ({
  id: pgMembership.id,
  name: pgMembership.name,
  price: parseFloat(pgMembership.price),
  features: Array.isArray(pgMembership.features) ? pgMembership.features : [],
  createdAt: pgMembership.created_at,
  updatedAt: pgMembership.updated_at
});

export const formatPostgresMembershipToModel = (pgMembership: any): Membership => ({
  id: pgMembership.id,
  name: pgMembership.name,
  price: parseFloat(pgMembership.price),
  features: Array.isArray(pgMembership.features) ? pgMembership.features : [],
  createdAt: new Date(pgMembership.created_at),
  updatedAt: new Date(pgMembership.updated_at)
});

// Seed membership tiers
const seedMembershipTiers = async (client: any): Promise<void> => {
  try {
    // Check if memberships already exist
    const existingResult = await client.query('SELECT COUNT(*) as count FROM memberships');
    const count = parseInt(existingResult.rows[0].count);
    
    if (count > 0) {
      console.log(`✅ Membership tiers already seeded (${count} tiers found)`);
      return;
    }
    
    // Insert default membership tiers
    for (const tier of DEFAULT_MEMBERSHIP_TIERS) {
      await client.query(
        'INSERT INTO memberships (id, name, price, features) VALUES ($1, $2, $3, $4) ON CONFLICT (name) DO NOTHING',
        [tier.id, tier.name, tier.price, JSON.stringify(tier.features)]
      );
    }
    
    console.log(`✅ Seeded ${DEFAULT_MEMBERSHIP_TIERS.length} membership tiers`);
  } catch (error) {
    console.error('❌ Error seeding membership tiers:', error);
  }
};